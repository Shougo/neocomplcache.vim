neocomplcache

究極のVim的補完環境
                        Shougo

--------------------------------
まずは自己紹介

Shougo
Vim歴４年目。だが、本格的にVimに目覚めたのはごく最近のこと。
Vimを使い始めたのは、Vimは多数の言語に対してsyntaxハイライトができたから。
neocomplcacheの更新はだいぶ前に止まったはずなのに、
なぜかどんどん機能が増えていく……。

--------------------------------
代表作
・bufstatus
http://github.com/Shougo/shougo-s-github/blob/a1a9d5d0a9a4a53fedec52f7d1be0c9c9341f787/vim/plugin/bufstatus.vim
・vimshell
https://github.com/Shougo/vimshell/tree
・neocomplcache
https://github.com/Shougo/neocomplcache/tree

今回はneocomplcacheについて話をします。

--------------------------------
neocomplcacheとは？

VimScriptによって実装された究極の補完環境。
タグ補完やディクショナリ補完も自前で実装しています。
高速化するために、並々ならぬ苦労が……。

--------------------------------
似た感じのスクリプト

・autocomplpop.vim
・auto-complete.el

--------------------------------
autocomplpop.vimの良いところ
・Vim標準の補完を呼ぶので高速
・一部の言語はオムニ補完にも対応
・情報が多い

autocomplpop.vimの悪いところ
・カスタマイズがしづらい
・補完機能はVimの機能に制限されてしまう
・ATOK X3で暴走する
・日本語入力中も補完候補が出る
・最近更新されてない

--------------------------------
auto-complete.elの良いところ
・補完機能のカスタマイズがしやすい
・キーバインドのカスタマイズが容易
・情報が多い
・プラグインも豊富
・比較的開発も盛ん

auto-complete.elの悪いところ
・Emacsen専用なので、Vimmerには使えない
・補完候補のスクロールができない
・標準では候補の絞り込みができない
・標準では部分マッチが使えない
・補完候補の情報が表示されない

--------------------------------
neocomplcacheの良いところ
・候補の絞り込みができる
・部分マッチもできる
・スペルチェックもできる
・単語の出現頻度によってソートができる
・補完機能のカスタマイズがしやすい
・補完機能はほとんど自前実装
・毎週更新？
・プラグインで拡張できる

neocomplcacheの悪いところ
・情報はほとんど無い
・補完機能のカスタマイズがしやすいが、ドキュメントはない
・候補が多いと遅くなる（ことがある）
・開発が早いので、不安定（なことがある）
・内部でcompletefuncを使っているので、completefuncが設定されている場合は動作しない

--------------------------------
neocomplcacheの歴史

これまで愛用していたautocomplpop.vimが
Linux GVim上のATOK X3でおかしくなる
　　　　　　↓
それなら自分で作ってしまえ！
　　　　　　↓
部分マッチも欲しいなぁとか思い始める
　　　　　　↓
それなら自分で作ってしまえ！
　　　　　　↓
補完が遅いなぁと思い始める
　　　　　　↓
それなら結果をキャッシュしてしまえ！
　　　　　　↓
　　　　さらなる暴走
　　　　　　↓
　　そして現在に至る……

詳しくはChangeLog:で。

--------------------------------
neocomplcacheの代表的機能

・キーワードの使用頻度によるランク付け
・シンタックスごとのキーワード補完
・部分マッチ
・数字キーによるクイックマッチ
・ディクショナリ補完、タグ補完
・ワイルドカードによる検索結果の絞り込み
・結果のキャッシュによる高速化
・MFU Dictionaryによる自動辞書登録
・ディレクトリ補完
・カーソル後方のキーワードに応じた補完
・SmartCase
・豊富なカスタマイズ項目
・文脈依存補完（3-gram completion）
・Omni補完
・スペルチェック
・ローカルタグ補完
・自動タグファイルアップデート
・キーワード補完を試す
・Same filetype completion
・preview windowに対応
・シンタックス補完
・プラグインで拡張可能

--------------------------------
キーワードの使用頻度によるランク付け

キーワード収集を自前で行っているため、可能になりました。
キーワードの使用回数を記録し、補完時の順位に反映させることができます。
使用頻度が高いものが上の方に来て、かなり便利です。

--------------------------------
シンタックスごとのキーワード補完

言語ごとにキーワードを登録して補完ができるので、
例えばRubyでは$や@, ., ::といったキーワードに反応して補完ができます。
標準でも様々な言語に対応していますが、
「この言語に対応して欲しい」という要望があれば、可能な限り対応します。

--------------------------------
部分マッチ

Vim標準のキーワード補完では先頭マッチのみですが、neocomplcacheでは標準で部分マッチが有効です。
ただし、部分マッチによる候補は使用頻度が低いと考えられるため、下の方に配置されます。

--------------------------------
数字キーによるクイックマッチ

fuzzyfinderにインスパイア。
<TAB>や<C-p>, <C-n>を連打しなくても、
補完候補横に表示されている数値を入力するだけで、補完ができます。
ルーチンの改良により、二桁まで対応。
よくよく調べてみると、ATOKにも同様の機能がありますね。

--------------------------------
ディクショナリ補完、タグ補完

ディクショナリ補完やタグ補完も自前で実装しています。
ファイルタイプ別に登録することで、裏で自動的に読み込み、補完に使えます。
読み込むタグはカレントディレクトリごとに設定できます。
特殊なディクショナリとして、バッファディクショナリというものもあります。
これはインクルードファイルの補完用です。ただ、パーサをかかないと意味がありません。

--------------------------------
ワイルドカードによる検索結果の絞り込み

多数の候補がある場合、絞り込みが大変なので実装しました。
hoge*piyoと入力すると、hogeがつき、その後にpiyoとなるものにマッチします。
正規表現的にはhoge.*piyoと同じ意味です。

追記：
Ver.2.01より、$*や@*, .*など、あらゆるところでワイルドカードが使えるようになりました。
スペルが分からないときに便利です。

追記２：
Ver.2.10より、-のワイルドカードが追加されました。
hoge-piyoは正規表現的にはhoge.\+piyoと同じ意味です。

--------------------------------
結果のキャッシュによる高速化

プラグインの名前の元にもなっている機能です。
あまりに初期段階の補完が遅すぎて、我慢ならなくなったので実装しました。
バッファ全体を一定のキャッシュラインで分割し、
キャッシュライン単位でキーワードの収集を行います。

--------------------------------
MFU Dictionaryによる自動辞書登録

キーワードの使用頻度を解析し、よく使われているものを辞書ファイルに登録して、
次回読み込みます。辞書をいちいち用意する必要がないので便利です。
g:NeoComplCache_AlphabeticalOrder = 0でないと意味がありません（デフォルト）。

この機能を使用するには、
let g:NeoComplCache_EnableMFU = 1
とする必要があります。

追記：
仕様変更により、MFUでは語のつながりを記録しません。
前バージョンとは違うので注意。

--------------------------------
ディレクトリ補完

バッファ内で../といったディレクトリ名を入力するとファイル名の補完ができます。
autocomplpopで便利だったので、移植しました。
特にVimShellではこれがないと生きていけません。
<TAB>による補完が馬鹿らしくなります。

--------------------------------
カーソル後方のキーワードに応じた補完

|にカーソルがあるとします。
|e
ここでhogeを補完すると、hogのみが補完され、結果はhog|eとなります。
初めはそこまで便利だとは思っていませんでしたが、使ってみるとソースの修正時に便利。
この機能はViViにインスパイアされました。

--------------------------------
SmartCase

これを設定すると、g:NeoComplCache_IgnoreCaseのとき（デフォルト）、
hoge -> hoge,Hogeにマッチ。
Hoge -> Hogeにマッチ。
となる。
つまり、大文字が含まれるときは大文字小文字を区別するようになります。
大文字小文字で意味が変わる、RubyやCのマクロを使うときには便利です。

この機能を使用するには、
let g:NeoComplCache_SmartCase = 1
とする必要があります。

--------------------------------
豊富なカスタマイズ項目

調子に乗って機能を増やしていたら、たくさんの設定ができるようになっていました。
設定をカスタマイズすれば、Vim標準の補完機能をエミュレーションすることもできます。
ただしその場合、neocomplcacheを使う意味は薄れますが……。

--------------------------------
文脈依存補完（3-gram completion）

文脈を解析し、補完する機能が実験的に実装されました。
例えば、バッファ内に
hoge piyo
と入力しているとすると、hogeの後にはpiyoが来やすいと認識、
補完時にpiyoが上の方に来ます。

追記：
3-gram completionも実装しました！
これで、より精度の高い補完が可能になります。

この機能を使用するには、
let g:NeoComplCache_PreviousKeywordCompletion = 1
とする必要があります。

--------------------------------
Omni補完

thincaさんに要望されたので追加しました。
基本的にはautocomplpopのコードを移植し、C, C++, JavaScript, PHPといった新たな言語にも対応。
Rubyで,や.を入力したり、HTMLでタグが補完できます。
ただしあまりテストしていないので、きちんと動かないかもしれません。
あと候補が多いためか、動作が若干重いです。

追記：
VimScriptでは、Vim commands completionを呼び出した方が都合が良いため、
そのようにしました。コマンドの先頭に:があると、補完が有効になります。

let g:NeoComplCache_OmniPatterns = {}
let g:NeoComplCache_OmniPatterns['無効にしたいファイルタイプ'] = ''
とすると、無効にできます。

--------------------------------
スペルチェック

Google検索でのスペルチェックと似た機能です。
ある程度の長さがある文字を入力すると、キャッシュ中にあるよく似た候補が表示されます。
例えばhogeと入力していると、hegeが候補に出てきたりします。
ソースのコピペ修正に便利でしょう。
ただし重いので、手動補完（<C-x><C-u>）したときにしか出てきません。

この機能を使用するには、
let g:NeoComplCache_SimilarMatch = 1
とする必要があります。

--------------------------------
ローカルタグ補完

タグファイルの設定をしなくても、バッファと同じディレクトリにある
tagsファイルを自動的に読み込むようになりました。
しかもtagsのキーワードを認識し、ちゃんと補完します。

--------------------------------
自動タグファイルアップデート

Omni補完を使用するにあたって、こまめなタグファイルのアップデートは
必要不可欠です。そこでファイル保存時にtagsが存在したら、
自動的にアップデートするようになりました。
少しの変更でアップデートすると、パフォーマンス的に問題があるので、
ある程度大きな変更があるときのみ更新します。

この機能を使用するには、
let g:NeoComplCache_TagsAutoUpdate = 1
とする必要があります。

--------------------------------
キーワード補完を試す

thincaさんの要望により、試験的に実装。
補完候補がない場合、キーワード補完を行います。
これを有効にすると、コマンドライン部が少しちらつくので注意してください。

追記：
januswelさんのエントリを参考に、
Perl以外ではインクルード補完を試してみることにしました。
追記２：
Ver.2.15より、g:NeoComplCache_MaxTryKeywordLengthを導入し、
入力されたキーワード文字がこれより多かったら、キーワード補完をしないようにしました。
これで補完時のちらつきが軽減されます。
追記３：
Ver.2.17より、g:NeoComplCache_TryDefaultCompletionが導入されました。
これが設定されている場合、まずキーワードを'default'にして補完を試します。
それでもだめならば、通常のキーワード補完を呼び出します。

この機能を使用するには、
let g:NeoComplCache_TryKeywordCompletion = 1
とする必要があります。

--------------------------------
Same filetype completion

昔のneocomplcacheでは、すべてのバッファから補完できたのですが、
最新版では同じfiletypeのバッファからしか補完できないようになりました。
しかしこれでは困る場合もあったので（例：C/C++でやりとりするとき）、
Same filetypeという概念を作り、
let g:NeoComplCache_SameFileTypeLists['c'] = 'cpp'
let g:NeoComplCache_SameFileTypeLists['cpp'] = 'c'
というように設定すれば、C/C++間のバッファで補完できるようになります。
一方だけ設定すれば、相互でない補完も可能です。

--------------------------------
preview windowに対応

preview windowが存在するとき、キャッシュしたときの行を表示するようになりました。
普通宣言がソースの上方に来ると考えられるので、
Intellisenseのように使い方を参照することができます。
ただし表示に時間がかかったり、ちらつきが激しいので注意してください。
デフォルトでは３つまでですが、g:NeoComplCache_MaxInfoListを設定することで、
より多くの情報を表示させることが可能です。

追記：
Ver.2.02より、この機能を使用するには、
let g:NeoComplCache_EnableInfo = 1
とする必要があります。

--------------------------------
シンタックス補完

Ver.2.17より、プラグインで実装しました。
:syn listの結果を解析し、補完候補に加えます。
１度目はキャッシュするので、若干時間がかかりますが、その後は高速に動作します。
バッファになくても補完できるので便利です。
ソースコードも短いので、プラグイン作りの勉強にも最適です。

--------------------------------
プラグインで拡張可能

Ver.2.10にて、複雑だったソースコードを分割し、ついに補完をプラグインで拡張できるようになりました。
他のプラグインを読み込む部分も実装したので、夢が広がります。
予定としては、ファイルタイプごとにプラグインを読み込めるようにしたいです。
プラグインの作り方については、今後ドキュメントを用意する予定ですが、
やる気があるならばautoload/neocomplcache/syntax_complete.vimを読んでみてください。
autoload/neocomplcacheディレクトリにプラグインファイルをおいておけば、補完時に自動で読み込まれます。

--------------------------------
私の設定

" Don't use autocomplpop.
let g:AutoComplPop_NotEnableAtStartup = 1
" Use neocomplcache.
let g:NeoComplCache_EnableAtStartup = 1
" Use smartcase.
let g:NeoComplCache_SmartCase = 1
" Use mfu.
let g:NeoComplCache_EnableMFU = 1
" Use previous keyword completion.
let g:NeoComplCache_PreviousKeywordCompletion = 1
" Use similar match.
let g:NeoComplCache_SimilarMatch = 1
" Use tags auto update.
let g:NeoComplCache_TagsAutoUpdate = 1
" Try keyword completion.
let g:NeoComplCache_TryKeywordCompletion = 1
" Try default completion.
let g:NeoComplCache_TryDefaultCompletion = 1
" Use preview window.
let g:NeoComplCache_EnableInfo = 1
" Delete keyword when rank is 0.
let g:NeoComplCache_DeleteRank0 = 0

" Define dictionary.
let g:NeoComplCache_DictionaryFileTypeLists = {
            \ 'default' : '',
            \ 'vimshell' : $HOME.'/.vimshell_hist',
            \ 'scheme' : $HOME.'/.gosh_completions'
            \ }

" Define keyword.
if !exists('g:NeoComplCache_KeywordPatterns')
    let g:NeoComplCache_KeywordPatterns = {}
endif
let g:NeoComplCache_KeywordPatterns['default'] = '\h\w*'

neocomplcache自体が標準で自分好みの設定になっているので、あまり凝った設定はしていません。
むしろ皆さんが使用するときは存分にカスタマイズすることを推奨します。
使用頻度を計算しないようにすれば、かなり高速化します。
VimShellの履歴ファイルを辞書として登録するのは便利なのでオススメ。
日本語が候補に出てくると煩わしいため、デフォルトで日本語を除外しています。

neocomplcacheを使用するに当たっては、Vimの補完関係の設定も重要なので、
参考までに私の設定を載せておきます。
" <TAB> completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" C-jでオムニ補完
inoremap <expr> <C-j>  &filetype == 'vim' ? "\<C-x>\<C-v>\<C-p>" : "\<C-x>\<C-o>\<C-p>"
" C-kを押すと行末まで削除
inoremap <C-k>  <C-o>D
" C-hで補完を続行しない
inoremap <expr><C-h> pumvisible() ? "\<C-y>\<C-h>" : "\<C-h>"
" C-nでneocomplcache補完
inoremap <expr><C-n>  pumvisible() ? "\<C-n>" : "\<C-x>\<C-u>\<C-p>"
" C-pでkeyword補完
inoremap <expr><C-p>  pumvisible() ? "\<C-p>" : "\<C-p>\<C-n>"
" 途中でEnterしたとき、ポップアップを消して改行し、
" 改行を連続して入力してもインデント部を保持する
inoremap <expr><CR> pumvisible() ? "\<C-y>\<CR>X\<BS>" : "\<CR>X\<BS>"

C-nでneocomplcacheの手動補完を呼び出します。
デバッグや、重すぎて候補が表示されなかったときなどに使います。
C-pはVim標準のキーワード補完。比較のため残してあります。
C-jでオムニ補完を起動します。filetypeがVimの時には、Vim commands completionを起動します。
C-hは一度ポップアップを消去し、ちらつかないようにしてます。

--------------------------------
低い知名度

autocomplpop: 12,400件
auto-complete.el: 15,300件
neocomplcache: 260件

                  Google調べ

徐々に増えてはいますが、まだまだ少ない……。

追記：
thincaさんに紹介されました！！
http://d.hatena.ne.jp/thinca/20090305/1236191531

メインで使っていただけているようで光栄です。
このエントリに刺激され、Omni補完を実装しました。

追記２：
secondlifeさんが試用しているようです。
http://subtech.g.hatena.ne.jp/secondlife/20090310/1236668086
気に入ってもらえるとうれしいですね。

--------------------------------
入手方法

http://github.com/Shougo/neocomplcache/tree/master （毎週更新）

ちゃんとしたドキュメントができたらwww.vim.orgにも登録したいです。

--------------------------------
使い方

まず、plugin/neocomplcache.vimを.vim/pluginにインストール。
そして、.vimrcで
let g:NeoComplCache_EnableAtStartup = 1
すると、Vimの起動時に自動的に有効になります。
手動で有効にしたいときには、
:NeoCompleCacheEnableを実行してください。
:NeoCompleCacheDisableで無効になります。

--------------------------------
今後の予定

考え得る限りほとんどの機能を実装しました。
もはや補完の域を抜け出してしまったような気がしますが……。
今後は補完機能をプラグインから読み込めるようにして、
auto-complete.elやanything.elみたいに、誰でも補完用ソースが記述できるようにしたいです。

追記：
syntaxcompleteの実装など、まだまだやることがありそうです。

--------------------------------
サポート

何か問題があれば、http://www.lingr.com/room/vim-users.jpまで！（宣伝）

--------------------------------
まとめ

せっかく作ったので、皆さん使ってみてください。
夢は「名無しのVim使い」で紹介されること。

--------------------------------
次回はVimShellを紹介するかも……。

続く？

--------------------------------
更新履歴

2009/04/03     neocomplcache Ver.2.17に対応。
2009/04/01     neocomplcache Ver.2.16に対応。
2009/03/31     設定例がバグっていたので修正。
2009/03/30     neocomplcache Ver.2.14に対応。
2009/03/27     neocomplcache Ver.2.11に対応。
2009/03/27     neocomplcache Ver.2.10に対応。
2009/03/26     neocomplcache Ver.2.02に対応。
2009/03/25     neocomplcache Ver.2.01に対応。
2009/03/20     neocomplcache Ver.2.00に対応。
2009/03/12     neocomplcache Ver.1.58に対応。
2009/03/8      neocomplcache Ver.1.54に対応。
2009/03/7      neocomplcache Ver.1.52に対応。
2009/03/6      neocomplcache Ver.1.50に対応。
2009/03/5      neocomplcache Ver.1.49に対応。
--------------------------------
